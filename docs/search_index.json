[["31_geonetworks.html", "Chapter 4 Geonetworks 4.1 Geotags 4.2 Hypercubes 4.3 Linkages 4.4 Visualization", " Chapter 4 Geonetworks We present here the program used for the elaboration of networks of states and regions that has been presented at the 3rd IMAGEUN workshop in Paris the 12-13 July 2021. 4.1 Geotags During this first step, we proceed in three steps to (1) the selection of the corpus, (2) the tokenization and cleaning of the text and (3) the creation of compounds and the extraction of tags related togeographical names. 4.1.1 Select corpus We load a coprus of title of news stored in quanteda forma # Load external corpus qd&lt;-readRDS(&quot;quanteda/fr_FRA_figaro.RDS&quot;) 4.1.2 Tokenize We proceed to a first tokenization with minimal option and we save the results in a file as the time of computation is very long. In the french case, we eliminate the apostrophe # Tokenize text toks&lt;-tokens(qd) # Split french apostroph toks&lt;- tokens_split(toks, &quot;&#39;&quot;) 4.1.3 identify geotags We produce a list of tags based on a dictionary. To do that it is necessary to transform the keywords in blankspace into compounds. It is also important to add external compounds that can be a problem. List of tags are produced for the whole dictionary but also for the different subtypes. Tags are uique at sentence level. # Load tags dictionary tags&lt;-read.csv2(&quot;data/corpora/TUN/geo_names_fr_V2.csv&quot;, header=T, sep=&quot;;&quot;) # create compounds presents in the dictionnary tags$ntoks&lt;-ntoken(tokens(tags$tokens)) sel&lt;-tags[tags$ntoks&gt;1,] toks2&lt;-tokens_compound(toks, pattern=phrase(sel$tokens)) # Create other compounds of interest not present in dictionary (e.g. Europe 1) comp &lt;- phrase(c(&quot;europe 1&quot;, &quot;france inter&quot;, &quot;union européenne&quot;, &quot;conseil de l europe&quot;, &quot;agence france presse&quot;)) toks2&lt;-tokens_compound(toks2, pattern=comp) # Build dictionnary keys &lt;-gsub(&quot; &quot;,&quot;_&quot;,tags$tokens) dict&lt;-as.list(keys) names(dict)&lt;-tags$code dico&lt;-dictionary(dict) # Identify geo tags (states or reg or org ...) toks_tags &lt;- tokens_lookup(toks2, dico) toks_tags &lt;- lapply(toks_tags, unique) toks_tags&lt;-as.tokens(toks_tags) list_tags&lt;-function(x){res&lt;-paste(x, collapse=&#39; &#39;)} qd$tags&lt;-as.character(lapply(toks_tags,FUN=list_tags)) qd$nbtags&lt;-ntoken(toks_tags) # Save corpus saveRDS(qd,&quot;quanteda/fr_FRA_figaro_geo.Rdata&quot;) 4.2 Hypercubes During this second step, we will produce aggregates of news called hypercubes which provide a number of to links between geographical units found in the text. Different options are possible which desserve the creation of a function with parameters. 4.2.1 Load data We start from the results of the previous step and we load the dictionary used for tagging and the tags describing the texts. Th example chosen is * Le Figaro*. # Load quanteda corpus with geotags qd&lt;-readRDS(&quot;quanteda/fr_FRA_figaro_geo.Rdata&quot;) 4.2.2 Hypercube Function We start by the creation of a global hypercube crossing all the geographical tags by media and data, whatever their type (state or region). hypercube &lt;-function(qd = qd, when = &quot;date&quot;, when_cut = &quot;year&quot;, who = &quot;source&quot;, where1 = &quot;tags&quot;, where2 = &quot;tags&quot;) { # create data.table accroding to parameter chosen don&lt;-docvars(qd) df&lt;-data.table(id = docid(qd), who = don[,who], when = as.character(cut(don[,when],breaks=when_cut)), where1 = don[,where1], where2 = don[,where2]) # add code _no_ for empty fields df$where1[df$where1==&quot;&quot;]&lt;-&quot;_no_&quot; df$where2[df$where2==&quot;&quot;]&lt;-&quot;_no_&quot; # unnest where1 df&lt;-unnest_tokens(df,where1,where1,to_lower=F) # unnest where2 df&lt;-unnest_tokens(df,where2,where2,to_lower=F) # define number of occurence by id nb&lt;-df[,.N,list(id)] %&gt;% mutate(wgt = 1/N) %&gt;% select(-N) df&lt;-df %&gt;% left_join(nb) rm(nb) # Aggregate hc&lt;- df[,.( tags = .N, news=sum(wgt)) ,.(who, when,where1,where2)] # Convert date to time hc$when&lt;-as.Date(hc$when) # return hypercube return(hc) } 4.2.3 Build hypercube Depending on the hypothesis, different types of hypercubes can be quickly created with the function. This hypercube is dedicated to the creation of a full network linking geographical tags. We present here an example where we mix all geo names (states and regions together). But we can further create differences between links relating states, links relating regions, linkes relating states and regions, etc. hc_geo_geo &lt;- hypercube(qd = qd, when = &quot;date&quot;, when_cut = &quot;months&quot;, who = &quot;source&quot;, where1 = &quot;tags&quot;, where2 = &quot;tags&quot;) head(hc_geo_geo) FALSE who when where1 where2 tags news FALSE 1: fr_FRA_figaro 2019-01-01 _no_ _no_ 2769 2769.00 FALSE 2: fr_FRA_figaro 2019-01-01 COD COD 25 25.00 FALSE 3: fr_FRA_figaro 2019-01-01 QAT QAT 3 3.00 FALSE 4: fr_FRA_figaro 2019-01-01 CHN_HKG CHN_HKG 4 4.00 FALSE 5: fr_FRA_figaro 2019-01-01 GAB GAB 5 5.00 FALSE 6: fr_FRA_figaro 2019-01-01 SYR SYR 49 46.75 4.3 Linkages The objective of this step is to propose a random model of allocation of linkages between two groups of geographical units that can be the same or different. We start from an hypercube (see. step 2) which is transformed into an interaction matrix where a double constraint model is applied. Different options are introduced, in particular for the filtering of geographical units wit small number of occurences. As in previous section, we propose a function dedicated to the task of estimation of the model of interest. 4.3.1 Select links We want to produce a selection of the hypercube data set and to normalize the datain order to keep only two columns of location corresponding to where1, where2. The function will also help us to select data according to the dimensions who and when and the possible selection or exclusion of elements from where1 and where2 hc_filter &lt;- function(don = hc, who = &quot;who&quot;, when = &quot;when&quot;, where1 = &quot;where1&quot;, where2 = &quot;where2&quot;, wgt = &quot;tags&quot;, self = FALSE, when_start = NA, when_end = NA, who_exc = NA, who_inc = NA, where1_exc = NA, where1_inc = NA, where2_exc = NA, where2_inc = NA) { df&lt;-data.table(who = don[[who]], when = don[[when]], where1 = don[[where1]], where2 = don[[where2]], wgt = don[[wgt]]) # Select time period if (is.na(when_start)==FALSE) { df &lt;- df[when &gt;= as.Date(when_start), ]} if (is.na(when_end)==FALSE) { df &lt;- df[when &lt;= as.Date(when_end), ]} # Select who if (is.na(who_exc)==FALSE) { df &lt;- df[!(who %in% who_exc), ]} if (is.na(who_inc)==FALSE) { df &lt;- df[(who %in% who_inc), ]} # Select where1 if (is.na(where1_exc)==FALSE) { df &lt;- df[!(where1 %in% where1_exc), ]} if (is.na(where1_inc)==FALSE) { df &lt;- df[(where1 %in% where1_inc), ]} # Select where2 if (is.na(where2_exc)==FALSE) { df &lt;- df[!(where2 %in% where2_exc), ]} if (is.na(where2_inc)==FALSE) { df &lt;- df[(where2 %in% where2_inc), ]} # eliminate internal links if (self==FALSE) { df &lt;- df[(where1 != where2), ]} return(df) } Application now: hc&lt;-hc_filter(don = hc_geo_geo, wgt = &quot;tags&quot;, where1_exc = c(&quot;_no_&quot;), where2_exc = c(&quot;_no_&quot;), self = FALSE ) ` 4.3.2 Create interaction matrix Now, we transform the data in a matrix of interaction (i,j,Fij) whre we fill with 0 the empty cells. After that we eliminate the lines and columns wich do not fulfill one of the two conditions of salience and diversity : Salience (s1,s2) : For example, we will eliminate a country that has not be mentioned at less 20 times in the news. To do that, we compute the marginal sums of the matrix in lines (1) and columns (2) and we check if the condition is fulfilled. Diversity (n1,n2,k) : We consider that a linkage between units i and j exist if Fij &gt; k. Then we compute the number of links where the condition is verified in lines (1) and columns. To do that we compute a boolean matrix where the value are 0 if Fij &lt; k and 1 if Fi &gt;= k. And we verify if the marginal sums of the matrix verify the conditions n1 and n2. The default values are s1 = s2 = 5 n1 = n2 = 3 k = 0 They depend from the type of weight used. The previous parameter are adapted to the case where we use fractions of news as weighting criteria. They should be higher if we decide to use the number of tags. To do that, we create a specific function called build_mat . build_int &lt;- function(don = don, # a dataframe with columns i, j , Fij i = &quot;where1&quot;, j = &quot;where2&quot;, Fij = &quot;wgt&quot;, s1 = 1, s2 = 1, n1 = 1, n2 = 1, k = 0) { df&lt;-data.table(i=don[[i]],j=don[[j]],Fij=don[[Fij]]) int &lt;-df[,.(Fij=sum(Fij)),.(i,j)] int&lt;-dcast(int,formula = i~j,fill = 0) mat&lt;-as.matrix(int[,-1]) row.names(mat)&lt;-int$i mat&lt;-mat[apply(mat,1,sum)&gt;=s1,apply(mat,2,sum)&gt;=s2 ] m0&lt;-mat m0[m0&lt;k]&lt;-0 m0[m0&gt;=k]&lt;-1 mat&lt;-mat[apply(m0,1,sum)&gt;=n1,apply(m0,2,sum)&gt;=n2 ] int&lt;-melt(mat) names(int) &lt;-c(&quot;i&quot;,&quot;j&quot;,&quot;Fij&quot;) return(int) } Application now: int &lt;- build_int(don = hc, s1=1, s2=1, n1=1, n2=1, k=0) head(int) FALSE i j Fij FALSE 1 AFG AFG 0 FALSE 2 AFRIQUE AFG 0 FALSE 3 AF_centra AFG 0 FALSE 4 AF_est AFG 0 FALSE 5 AF_nord AFG 0 FALSE 6 AF_ouest AFG 0 4.3.3 Estimate random model We can now solve the model and compute the most important and significant residuals according to various criteria. We will therefore build a model where i, j and Fij will be completed by a column Eij which describe the expected number of news where i and j would be associated if the allocation was made randomly. It is important to check if the size of the matrix is not too large, in order to avoid computational crash  As a security, we introduce a parameter maxsize = 100000 defined by the product of numer of lines and columns If you decide to increase this parameter, it is at your own risk  When i and j describe the same spatial units (e.g. state x state or reg x reg), it can be important to eliminate the diagonal if it is empty or if we decide to focus only on external relations between geographical objects. For this reason, we introduce a parameter diag = TRUE or FALSE in the function rand_int() that solves the model We can eventually add to the data set further columns related to the residuals measures in different forms if we activate the parameter resid=TRUE : Rabs_ij = Fij-Eij : absolute residuals Rrel_ij = Fij/Eij : relative residuals Rchi_ij = sign(R_absij) x (Rabs_ij)^2 / Eij rand_int &lt;- function(int = int, # A table with columns i, j Fij maxsize = 100000, diag = FALSE, resid = FALSE) { # Eliminate diagonal ? if (diag==FALSE) { int &lt;- int[as.character(int$i) != as.character(int$j), ]} # Compute model if size not too large if (dim(int)[1] &lt; maxsize) { # Proceed to poisson regression model mod &lt;- glm( formula = Fij ~ i + j,family = &quot;poisson&quot;, data = int) # Add residuals if requested if(resid == TRUE) { # Add estimates int$Eij &lt;- mod$fitted.values # Add absolute residuals int$Rabs_ij &lt;- int$Fij-int$Eij # Add relative residuals int$Rrel_ij &lt;- int$Fij/int$Eij # Add chi-square residuals int$Rchi_ij &lt;- (int$Rabs_ij)**2 / int$Eij int$Rchi_ij[int$Rabs_ij&lt;0]&lt;- -int$Rchi_ij[int$Rabs_ij&lt;0] } } else { paste (&quot;Table &gt; 100000 - \\n modify maxsize = parameter \\n if you are sure that your computer can do it !&quot;)} # Export results int$i&lt;-as.character(int$i) int$j&lt;-as.character(int$j) return(int) } 4.3.3.1 Model wit France mod&lt;-rand_int(int, resid = TRUE, diag = FALSE) We can have a look at the more important positive residuals in absolute value : tab&lt;-mod[order(-mod$Rabs_ij),] tab&lt;-tab[(tab$i &gt; tab$j),] kable(head(tab,10) , digits=2, caption = &quot;Positive residuals&quot;) Table 4.1: Positive residuals i j Fij Eij Rabs_ij Rrel_ij Rchi_ij 20869 TUR SYR 45 5.26 39.74 8.56 300.54 10992 USA IRN 33 6.49 26.51 5.08 108.20 10637 PAK IND 24 0.65 23.35 37.20 845.54 8658 ITA FRA 61 38.02 22.98 1.60 13.89 8642 GBR_ENG FRA 35 17.65 17.35 1.98 17.06 4674 USA CHN 26 8.95 17.05 2.91 32.51 18766 UKR RUS 17 1.60 15.40 10.65 148.68 7506 FRA EUROPE 60 45.85 14.15 1.31 4.36 8674 MCO FRA 17 4.35 12.65 3.91 36.76 2160 FRA AUS 25 12.59 12.41 1.99 12.22 4.4 Visualization 4.4.1 Function We have created a prototype of geonetwork visualization function with different parameters making possible to display different graphs. geo_network&lt;- function(don = don, from = &quot;i&quot;, to = &quot;j&quot;, size = &quot;Fij&quot;, minsize = 1, maxsize = NA, test = &quot;Fij&quot;, mintest = 1, loops = FALSE, title = &quot;Network&quot;) { int&lt;-data.frame(i = as.character(don[,from]), j = as.character(don[,to]), size = don[,size], test = don[,test] ) if (is.na(minsize)==FALSE) {int =int[int$size &gt;= minsize,]} if (is.na(maxsize)==FALSE) {int =int[int$size &lt;= maxsize,]} if (is.na(mintest)==FALSE) {int =int[int$test &gt;= mintest,]} nodes&lt;-data.frame(code = unique(c(int$i,int$j))) nodes$code&lt;-as.character(nodes$code) nodes$id&lt;-1:length(nodes$code) nodes$label&lt;-nodes$code # Adjust edge codes edges &lt;- int %&gt;% mutate(width = 5+30*size / max(size)) %&gt;% left_join(nodes %&gt;% select(i=code, from = id)) %&gt;% left_join(nodes %&gt;% select(j=code, to = id )) # compute nodesize tot&lt;-int %&gt;% group_by(i) %&gt;% summarize(size =sum (size)) %&gt;% select (code=i,size) tot$code&lt;-as.factor(tot$code) nodes &lt;- left_join(nodes,tot) %&gt;% mutate(value = sqrt(10 *size/max(size))) #sel_nodes &lt;-nodes %&gt;% filter(code %in% unique(c(sel_edges$i,sel_edges$j))) # eliminate loops if(loops == FALSE) {edges &lt;- edges[edges$from &lt; edges$to,]} net&lt;- visNetwork(nodes, edges, main = title, height = &quot;700px&quot;, width = &quot;100%&quot;) %&gt;% visNodes(scaling =list(min =20, max=60, label=list(min=20,max=80, maxVisible = 20)))%&gt;% visOptions(highlightNearest = TRUE, # selectedBy = &quot;group&quot;, # manipulation = TRUE, nodesIdSelection = TRUE) %&gt;% visInteraction(navigationButtons = TRUE) %&gt;% visLegend() %&gt;% visIgraphLayout(layout =&quot;layout.fruchterman.reingold&quot;,smooth = TRUE) net return(net) } 4.4.1.1 Model without France mod2&lt;-rand_int(int %&gt;% filter(i != &quot;FRA&quot;, j !=&quot;FRA&quot;), resid = TRUE, diag = FALSE) We can have a look at the more important positive residuals in absolute value : tab&lt;-mod2[order(-mod2$Rabs_ij),] tab&lt;-tab[(tab$i &gt; tab$j),] kable(head(tab,10) , digits=2, caption = &quot;Positive residuals&quot;) Table 4.2: Positive residuals i j Fij Eij Rabs_ij Rrel_ij Rchi_ij 20579 TUR SYR 45 5.36 39.64 8.39 292.85 10763 USA IRN 33 8.18 24.82 4.04 75.37 10410 PAK IND 24 0.77 23.23 31.20 701.51 18489 UKR RUS 17 1.82 15.18 9.35 126.70 4645 USA CHN 26 11.20 14.80 2.32 19.54 6994 ITA ESP 17 4.57 12.43 3.72 33.75 10694 IRQ IRN 14 1.88 12.12 7.45 78.18 12851 TUR LBY 14 2.08 11.92 6.74 68.47 8765 ITA GBR_ENG 13 2.35 10.65 5.52 48.17 2122 CHN AUS 13 2.45 10.55 5.30 45.33 4.4.2 Raw network We can firstly provide a basic view of the network using the default parameters wich visualize all connections greater to zero. 4.4.2.1 With France geo_network(mod, size = &quot;Fij&quot;, minsize = 0, test = &quot;Fij&quot;, mintest = 5) 4.4.2.2 Without France geo_network(mod2, size = &quot;Fij&quot;, minsize = 0, test = &quot;Fij&quot;, mintest = 5) 4.4.3 Preferential links But we can also visualize the most significant links by changing the criteria of size and introducing a test of significance : 4.4.3.1 With France geo_network(mod, size = &quot;Rabs_ij&quot;, minsize = 2, test = &quot;Rchi_ij&quot;, mintest = 3.84) 4.4.3.2 Without France geo_network(mod2, size = &quot;Rabs_ij&quot;, minsize = 2, test = &quot;Rchi_ij&quot;, mintest = 3.84) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
